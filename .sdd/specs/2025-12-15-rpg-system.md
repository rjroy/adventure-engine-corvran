---
version: 1.2.0
status: Under Review
created: 2025-12-15
last_updated: 2025-12-15
authored_by:
  - Ronald Roy <gsdwig@gmail.com>
---

# RPG System Integration Specification

## Executive Summary

Adventure Engine currently provides AI-driven narrative adventures without mechanical gameplay systems. This specification defines a pluggable RPG framework that enables adventures to include structured game mechanics—character attributes, skill checks, dice rolls, combat, and NPC management—while preserving the narrative-first experience.

The system stores RPG definitions in adventure markdown files (e.g., `System.md` or `System/*.md`), allowing each adventure to define its own rules including NPC templates (similar to a monster manual). A dice MCP tool provides consistent, auditable randomization with GM-controlled visibility. The framework abstracts common RPG concepts (attributes, skills, checks, combat, NPCs) so diverse systems (d20, Fudge, Apocalypse World, etc.) can be implemented without code changes.

## User Story

As an **adventure creator**, I want to define RPG mechanics in markdown files, so that my adventures can include structured character progression, skill checks, and combat without requiring code changes.

As an **adventure creator**, I want to define NPC templates (like a monster manual), so that the GM can quickly create consistent enemies and allies during play.

As a **player**, I want guided character creation and transparent game mechanics, so that I understand how my choices affect outcomes.

## Stakeholders

- **Primary**: Adventure creators (define systems), players (experience mechanics)
- **Secondary**: Backend maintainers (MCP tools, state management)
- **Tertiary**: Community contributors (create shareable system definitions)

## Definitions

- **System Definition**: Markdown file(s) in adventure directory declaring RPG mechanics. Minimum required: dice types supported. Optional: attributes, skills, combat rules, NPC templates.
- **NPC (Non-Player Character)**: A GM-controlled character with mechanical properties (stats, HP, skills) that can participate in skill checks and combat. Created dynamically by GM during play.
- **NPC Template**: A predefined NPC type in the system definition (e.g., "Goblin", "Slime", "Dragon") with default stats, similar to entries in a monster manual. GM can create instances from templates or define NPCs ad-hoc.
- **Combat Structure**:
  - *Turn-based*: Discrete turns with initiative order, action economy (e.g., d20 systems)
  - *Narrative*: No mechanical turns, GM narrates outcomes based on checks (e.g., Fate)
  - *Hybrid*: Structured exchanges triggered by player moves with narrative flexibility (e.g., Apocalypse World)
- **Trackable**: State property readable/writable via MCP tools and persisted in `state.json`
- **Derived Attribute**: Attribute calculated from other attributes (e.g., HP = CON × 10)
- **Character Creation Prompts**: Interactive questions presented as narrative dialogue, generated by GM based on system schema

## Success Criteria

1. Adventures can define RPG systems entirely in markdown files without code deployment
2. At least two different RPG philosophies (e.g., d20-like and narrative-like) can be implemented using the same framework
3. Dice rolls are logged and auditable; GM controls which rolls are visible to players
4. Character creation guides players through system-defined choices
5. Combat resolution follows system-defined rules without hardcoded mechanics
6. GM can create, manage, and remove NPCs with full mechanical properties during play

## Functional Requirements

### System Definition (REQ-F-1 through REQ-F-5)

- **REQ-F-1**: System definitions MUST be stored in adventure markdown files (`System.md` or `System/*.md`)
- **REQ-F-2**: System definitions MUST declare supported dice types (e.g., d20, d6, dF for Fudge dice)
- **REQ-F-3**: System definitions MUST declare attribute schema (names, valid ranges, derivation rules)
- **REQ-F-4**: System definitions MUST declare skill schema (names, linked attributes, check mechanics)
- **REQ-F-5**: System definitions MAY declare combat rules (initiative, actions, damage resolution)
- **REQ-F-5a**: System definitions MAY declare NPC templates (predefined creature/enemy types with default stats, like a monster manual)

### Character Creation (REQ-F-6 through REQ-F-10)

- **REQ-F-6**: Character creation MUST be guided through interactive prompts at adventure start
- **REQ-F-7**: Character creation prompts MUST be derived from system-defined attribute and skill schemas
- **REQ-F-8**: Players MUST be able to name their character and select from system-defined options
- **REQ-F-9**: Created characters MUST be persisted to adventure state (`playerCharacter` in `state.json`)
- **REQ-F-10**: Character sheet MUST be viewable on demand during play

### Dice Rolling (REQ-F-11 through REQ-F-15)

- **REQ-F-11**: Dice MCP tool MUST support standard polyhedral dice (d4, d6, d8, d10, d12, d20, d100)
- **REQ-F-12**: Dice MCP tool MUST support Fudge dice (dF: -1, 0, +1)
- **REQ-F-13**: Dice MCP tool MUST support rolling multiple dice with modifiers (e.g., "2d6+3")
- **REQ-F-14**: All dice rolls MUST be logged with timestamp, roll expression, and result
- **REQ-F-15**: Dice roll visibility MUST be controllable (player-visible vs. GM-hidden) per system rules

### Resolution Mechanics (REQ-F-16 through REQ-F-19)

- **REQ-F-16**: System definitions MUST declare resolution mechanics (how to interpret dice rolls for success/failure)
- **REQ-F-17**: GM MUST use `roll_dice` tool and interpret results according to system-defined resolution mechanics
- **REQ-F-18**: Resolution mechanics MUST support system-specific outcomes (success/failure, partial success, degrees of success, etc.)
- **REQ-F-19**: All resolution rolls MUST be logged via `roll_dice` for auditability

### Combat (REQ-F-20 through REQ-F-24)

- **REQ-F-20**: Combat structure (turn-based, narrative, hybrid) MUST be defined by the system
- **REQ-F-21**: Combat MCP tools MUST support initiative determination when system requires it
- **REQ-F-22**: Combat MCP tools MUST support damage calculation per system rules
- **REQ-F-23**: Player and NPC health/condition tracking MUST update automatically after combat actions
- **REQ-F-24**: Combat state (turn order, current combatant) MUST persist across player inputs, including both player and NPC combatants

### NPC Management (REQ-F-33 through REQ-F-39)

- **REQ-F-33**: GM MUST be able to create NPCs with system-defined attributes and skills via MCP tool
- **REQ-F-34**: NPCs MUST be persisted to adventure state (`npcs` array in `state.json`)
- **REQ-F-35**: NPCs MUST have the same trackable properties as player characters (stats, skills, HP, conditions)
- **REQ-F-36**: NPCs MUST be identifiable by unique name within the adventure
- **REQ-F-37**: GM MUST be able to update or remove NPCs via MCP tools
- **REQ-F-38**: NPC incapacitation/death MUST be handled per system-defined rules (removal, unconscious state, etc.)
- **REQ-F-39**: NPCs MAY have a reward property defining what players receive for overcoming them (XP, loot, story progression)

### State Management (REQ-F-25 through REQ-F-28)

- **REQ-F-25**: Player character and NPC attributes and skills MUST be persisted in `state.json`
- **REQ-F-26**: Character progression (XP, levels) MUST be tracked when system defines it
- **REQ-F-27**: Inventory and equipment MUST be trackable when system defines it
- **REQ-F-28**: Conditions/status effects MUST be trackable when system defines it (for both player and NPCs)

### Error Handling (REQ-F-29 through REQ-F-32)

- **REQ-F-29**: System definition parsing MUST validate required fields and return actionable error messages when malformed
- **REQ-F-30**: Dice tool MUST return error response for invalid expressions (e.g., "d7", "2d-6") with explanation
- **REQ-F-31**: Character creation MUST validate inputs against system constraints (valid ranges, required fields) and reject invalid values
- **REQ-F-32**: Character incapacitation (zero HP, death) MUST be handled per system-defined rules

## Non-Functional Requirements

- **REQ-NF-1** (Performance): Dice rolls MUST resolve in <100ms
- **REQ-NF-2** (Performance): Skill checks MUST resolve in <200ms including dice roll
- **REQ-NF-3** (Extensibility): New RPG systems MUST be addable without code changes
- **REQ-NF-4** (Auditability): All mechanical outcomes MUST be traceable to logged dice rolls
- **REQ-NF-5** (Backward Compatibility): Adventures without RPG systems MUST continue working unchanged
- **REQ-NF-6** (Testability): MCP tools MUST be testable with mock SDK (MOCK_SDK=true)
- **REQ-NF-7** (Debuggability): System definition errors MUST include file path and specific validation failure

## Explicit Constraints (DO NOT)

- Do NOT hardcode any specific RPG system's rules in backend code
- Do NOT require code deployment to add new RPG systems
- Do NOT expose dice roll seeds to players (internal implementation detail)
- Do NOT break existing adventures that lack system definitions
- Do NOT implement combat AI/tactics (GM narrates enemy actions)
- Do NOT implement multiplayer/party mechanics (single-player only for now)

## Technical Context

- **Existing Stack**: Bun, TypeScript, Claude Agent SDK, MCP tools, WebSocket protocol
- **Integration Points**:
  - `GameSession` (game-session.ts) - handles MCP tool callbacks
  - `buildGMSystemPrompt` (gm-prompt.ts) - includes system rules in prompts
  - `AdventureStateManager` - persists character state
  - Shared protocol (protocol.ts) - may need new message types
- **Patterns to Respect**:
  - MCP tool callbacks for mechanical actions (like existing `set_theme`)
  - Markdown files as Claude's memory (existing Read/Write tool pattern)
  - Zod validation at message boundaries
  - Mock SDK support for testing
- **Assumptions**:
  - Claude Agent SDK supports custom MCP tool registration with Zod schemas
  - Existing adventure markdown loading mechanism supports multiple files
  - System definitions use narrative markdown format (not structured JSON schema)

## Acceptance Tests

1. **System Loading**: Given an adventure with `System.md` defining d20-like rules, when adventure loads, then GM prompt includes system mechanics
2. **Character Creation**: Given a system with STR/DEX/CON attributes, when adventure starts, then player is guided through attribute assignment
3. **Dice Roll (Visible)**: Given a player-visible skill check, when GM calls dice tool, then roll result appears in narrative
4. **Dice Roll (Hidden)**: Given a GM-hidden perception check, when GM rolls, then result is logged but not shown to player
5. **Resolution (d20)**: Given d20 system with "roll d20 + modifier vs DC" resolution, when GM rolls 1d20+3 for DC 15 check, then GM interprets result per system rules
6. **Resolution (Fudge)**: Given Fudge system with ladder resolution, when GM calls 4dF+2 roll, then GM interprets result against difficulty ladder per system rules
7. **Combat Initiative**: Given turn-based combat system, when combat begins, then initiative order is determined and persisted
8. **Damage Application**: Given combat damage, when damage tool called, then character HP updates in state
9. **No System Fallback**: Given adventure without `System.md`, when loaded, then adventure runs as pure narrative (no mechanics)
10. **Resolution (PbtA)**: Given PbtA system with "2d6+stat: 6- fail, 7-9 partial, 10+ success" resolution, when GM rolls 2d6+1 and gets 8, then GM interprets as partial success per system rules
11. **Audit Trail**: Given multiple dice rolls during adventure, when audit log inspected, then each entry includes timestamp, expression, result, and visibility flag
12. **Invalid Dice Error**: Given dice expression "d7", when GM calls dice tool, then error response explains valid die types
13. **Malformed System Error**: Given `System.md` missing required dice section, when adventure loads, then error message identifies missing field
14. **NPC Creation**: Given a combat encounter, when GM creates NPC "Goblin" with HP 7 and AC 15, then NPC is persisted to state with unique identifier
15. **NPC from Template**: Given system with "Goblin" template defined, when GM creates NPC from template, then NPC inherits template stats
16. **NPC in Combat**: Given combat with player and 2 goblins, when initiative rolled, then all 3 combatants appear in turn order
17. **NPC Damage**: Given goblin with 7 HP, when player deals 4 damage, then goblin HP updates to 3
18. **NPC Death**: Given goblin reduced to 0 HP, when incapacitation checked, then goblin is handled per system rules (removed, unconscious, etc.)
19. **NPC Reward**: Given goblin with reward "50 XP", when goblin defeated, then GM can apply reward to player

## Design Decisions

The following questions were resolved during specification:

1. **Inheritance**: No inheritance in v1. Each adventure defines its complete system. Evaluate inheritance based on creator feedback in future versions.
2. **Format**: Narrative markdown for system definitions. Claude reads rules as natural language, providing flexibility for adventure creators.
3. **Bundled Systems**: Ship one d20-like reference implementation. Document pattern for community contributions.

## Out of Scope

- Multiplayer/party mechanics (multiple player characters)
- Visual character sheets in frontend (text-based for now)
- Automated enemy AI/tactics (GM narrates NPC actions)
- Character import/export formats (D&D Beyond, Roll20, etc.)
- Real-time combat (always turn-based or narrative)
- System definition inheritance (deferred to future version)
- NPC limits or automatic offloading of inactive NPCs (see Future Enhancements)

## Future Enhancements

The following are explicitly deferred but anticipated for future versions:

1. **NPC Offloading**: As adventures grow, active NPC count may impact performance. Future versions should support offloading "inactive" NPCs (e.g., defeated enemies, NPCs in other locations) to reduce state size while preserving them for potential recall.
2. **System Definition Inheritance**: Allow adventures to extend base systems rather than redefining everything.
3. **Visual Character/NPC Sheets**: Frontend UI for viewing character and NPC stats beyond narrative display.

---

**Next Phase**: Once approved, use `/spiral-grove:plan-generation` to create technical implementation plan.
