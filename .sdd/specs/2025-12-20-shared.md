---
version: 1.0.0
status: Under Review
created: 2025-12-20
last_updated: 2025-12-20
authored_by:
  - Claude Code <synthesized>
---

# Shared Protocol Module Specification

**Reverse-Engineered**: true
**Source Module**: shared

## Executive Summary

The shared protocol module defines the WebSocket communication contract between the Adventure Engine frontend and backend. It provides type-safe message schemas using Zod for runtime validation at message boundaries, ensuring data integrity across the client-server boundary. The module is language-agnostic in design but implemented in TypeScript, serving as the single source of truth for all WebSocket message formats, validation rules, and domain types used throughout the adventure gaming system.

This module enforces strict type safety through Zod schemas that validate at runtime, catching protocol violations before they propagate through the system. It supports bidirectional communication with distinct client-to-server and server-to-client message types, all validated through discriminated unions for type-safe message handling.

## User Story

As a developer working on either the frontend or backend of the Adventure Engine, I want a shared type definition and validation layer for WebSocket messages, so that I can confidently send and receive messages knowing they conform to the expected structure and will be validated at runtime, preventing type mismatches and protocol violations from causing runtime errors.

## Stakeholders

- **Primary**: Frontend developers (React/TypeScript), Backend developers (Bun/TypeScript)
- **Secondary**: QA engineers validating message flows, System architects ensuring protocol consistency

## Success Criteria

1. All WebSocket messages between frontend and backend must pass runtime validation using Zod schemas
2. Message parsing provides type-safe discriminated union access with zero type assertions required
3. Protocol changes are automatically reflected in both frontend and backend through shared import
4. Validation errors provide human-readable error messages suitable for debugging

## Functional Requirements

### Message Definition and Validation

- **REQ-F-1**: System must define Zod schemas for all client-to-server message types (authenticate, player_input, start_adventure, ping, abort, recap)
- **REQ-F-2**: System must define Zod schemas for all server-to-client message types (gm_response_start, gm_response_chunk, gm_response_end, adventure_loaded, authenticated, error, pong, theme_change, tool_status, panel_create, panel_update, panel_dismiss, recap_started, recap_complete, recap_error)
- **REQ-F-3**: System must use discriminated unions on the "type" field for both ClientMessage and ServerMessage schemas
- **REQ-F-4**: System must export TypeScript types inferred from Zod schemas for compile-time type checking
- **REQ-F-5**: System must provide parseClientMessage() function that validates unknown data and returns success/error result
- **REQ-F-6**: System must provide parseServerMessage() function that validates unknown data and returns success/error result
- **REQ-F-7**: System must provide formatValidationError() function that converts Zod errors to human-readable strings

### Domain Type Definitions

- **REQ-F-8**: System must define NarrativeEntry schema with id, timestamp (ISO 8601), type (player_input or gm_response), and content fields
- **REQ-F-9**: System must define HistorySummary schema for compacted history with generatedAt, model, entriesArchived, dateRange, and summary text
- **REQ-F-10**: System must define NarrativeHistory schema with entries array and optional summary field
- **REQ-F-11**: System must define ThemeMood enum schema with values: calm, tense, ominous, triumphant, mysterious
- **REQ-F-12**: System must define Genre enum schema with values: sci-fi, steampunk, low-fantasy, high-fantasy, horror, modern, historical
- **REQ-F-13**: System must define Region enum schema with values: city, village, forest, desert, mountain, ocean, underground, castle, ruins
- **REQ-F-14**: System must define ThemeChangePayload schema with mood, genre, region, backgroundUrl (nullable), and optional transitionDuration
- **REQ-F-15**: System must define ErrorCode enum schema with values: INVALID_TOKEN, ADVENTURE_NOT_FOUND, RATE_LIMIT, GM_ERROR, STATE_CORRUPTED, PROCESSING_TIMEOUT, SERVER_SHUTDOWN
- **REQ-F-16**: System must define Panel schema with id (alphanumeric + hyphens, max 32 chars), title (max 64 chars), content (markdown, max 2KB), position (sidebar/header/overlay), persistent (boolean), optional x/y (0-100 percentage), and createdAt timestamp
- **REQ-F-17**: System must define PlayerCharacter schema with nullable name, attributes record, and optional RPG fields (stats, skills, hp, conditions, inventory, xp, level, xpStyle)
- **REQ-F-18**: System must define NPC schema mirroring PlayerCharacter structure with additional fields (id, templateName, reward, isHostile, notes)
- **REQ-F-19**: System must define CombatState schema for turn-based combat with active status, round, initiativeOrder, currentIndex, and structure enum
- **REQ-F-20**: System must define DiceLogEntry schema with id, timestamp, expression, individualRolls array, total, context, visible flag, and requestedBy enum (gm or system)
- **REQ-F-21**: System must define InventoryItem schema with name, quantity, optional equipped flag, and optional properties record
- **REQ-F-22**: System must define SystemDefinition schema for RPG system metadata with rawContent, diceTypes, feature flags, and filePath

### Validation Constraints

- **REQ-F-23**: Panel ID validation must enforce alphanumeric characters and hyphens only, 1-32 characters
- **REQ-F-24**: Panel title validation must enforce 1-64 character limit
- **REQ-F-25**: Panel content validation must enforce maximum 2048 bytes (2KB)
- **REQ-F-26**: Panel overlay position (x/y) validation must enforce 0-100 range
- **REQ-F-27**: Timestamp fields must accept ISO 8601 string format
- **REQ-F-28**: NarrativeEntry type field must accept only "player_input" or "gm_response"
- **REQ-F-29**: Tool status state field must accept only "active" or "idle"

## Non-Functional Requirements

### Performance

- **REQ-NF-1** (Performance): Schema validation must complete in under 5ms for typical messages (verified through test execution speed)
- **REQ-NF-2** (Performance): Discriminated union parsing must provide O(1) type discrimination based on "type" field

### Usability

- **REQ-NF-3** (Usability): Validation error messages must include field path and specific error reason
- **REQ-NF-4** (Usability): Type inference must preserve discriminated union types after successful parsing, enabling exhaustive type checking

### Maintainability

- **REQ-NF-5** (Maintainability): All schemas must be defined in a single file (protocol.ts) to ensure consistency
- **REQ-NF-6** (Maintainability): Schema definitions must include JSDoc comments documenting purpose and constraints
- **REQ-NF-7** (Maintainability): Type exports must use TypeScript's `z.infer<>` utility to derive types from schemas, ensuring single source of truth

### Consistency

- **REQ-NF-8** (Consistency): All message schemas must follow the pattern `{ type: string, payload?: object }`
- **REQ-NF-9** (Consistency): All schema names must end with "Schema" suffix, all type names must match the schema name without "Schema"
- **REQ-NF-10** (Consistency): All enum schemas must use `z.enum([...])` for compile-time type safety

### Compatibility

- **REQ-NF-11** (Compatibility): Module must use Zod version 3.24.x for compatibility with Claude Agent SDK
- **REQ-NF-12** (Compatibility): Module must export ES modules (type: "module" in package.json)

## Explicit Constraints (DO NOT)

- Do NOT upgrade Zod to version 4.x (breaks Claude Agent SDK compatibility)
- Do NOT add validation logic beyond schema definition (validation logic belongs in consuming modules)
- Do NOT include implementation-specific types (e.g., WebSocket connection state, session management)
- Do NOT add default values in schemas (consumers must provide complete data)
- Do NOT export Zod schemas from backend/frontend re-export layers (only types and helper functions)
- Do NOT make required fields optional without protocol version negotiation
- Do NOT add business logic to validation helpers (parseClientMessage, parseServerMessage, formatValidationError are pure validation functions)
- Do NOT include Node.js or browser-specific types (module must remain platform-agnostic)

## Technical Context

- **Deployment Model**: LAN-only system. Frontend and backend are always deployed together from the same codebase version. No public internet exposure, so protocol-level security hardening (rate limiting, DoS protection, schema migration) is deferred to consumers or omitted entirely.

- **Existing Stack**:
  - TypeScript 5.7+ with strict mode enabled
  - Zod 3.24.1 for runtime schema validation
  - Bun runtime for backend (ES modules)
  - Vite/React for frontend (ES modules)

- **Integration Points**:
  - Frontend: Imported by `frontend/src/App.tsx`, `frontend/src/hooks/useWebSocket.ts`, `frontend/src/contexts/ThemeContext.tsx`, `frontend/src/contexts/PanelContext.tsx`
  - Backend: Re-exported through `backend/src/types/protocol.ts`, consumed by `backend/src/server.ts`, `backend/src/game-session.ts`, `backend/src/adventure-state.ts`
  - Testing: Unit tests in `backend/tests/unit/protocol.test.ts` validate all message schemas

- **Patterns to Respect**:
  - Discriminated unions using literal types for the "type" field
  - Zod schema definition followed by TypeScript type inference
  - Schema naming convention: `[TypeName]Schema` with exported type `[TypeName]`
  - Validation helpers return `{ success: true, data: T } | { success: false, error: ZodError }` pattern

## Acceptance Tests

1. **Client Message Validation**: Given a valid authenticate message `{ type: "authenticate", payload: { token: "abc123" } }`, when parsed with parseClientMessage(), then it returns success with properly typed data
2. **Server Message Validation**: Given a valid gm_response_chunk message `{ type: "gm_response_chunk", payload: { messageId: "msg-1", text: "Hello" } }`, when parsed with parseServerMessage(), then it returns success with properly typed data
3. **Invalid Message Rejection**: Given a message with unknown type `{ type: "invalid_type", payload: {} }`, when parsed with parseClientMessage(), then it returns failure with ZodError
4. **Missing Field Detection**: Given an authenticate message without token `{ type: "authenticate", payload: {} }`, when parsed, then it returns failure indicating missing "payload.token"
5. **Enum Validation**: Given a theme_change message with invalid mood "happy", when parsed, then it returns failure indicating invalid enum value
6. **Panel Constraint Validation**: Given a panel with ID containing spaces "my panel", when validated, then it returns failure indicating regex mismatch
7. **Panel Size Constraint**: Given a panel with content exceeding 2048 bytes, when validated, then it returns failure indicating max length exceeded
8. **Discriminated Union Type Safety**: Given a successfully parsed message of type "player_input", when accessed via TypeScript, then the compiler narrows the type to PlayerInputMessage and provides autocomplete for payload.text
9. **Error Formatting**: Given a validation error for missing fields, when formatted with formatValidationError(), then it returns a string containing field paths and error descriptions separated by semicolons
10. **Optional Field Handling**: Given a start_adventure message without adventureId `{ type: "start_adventure", payload: {} }`, when parsed, then it returns success (adventureId is optional)
11. **Nullable Field Handling**: Given a theme_change message with backgroundUrl: null, when parsed, then it returns success (backgroundUrl is explicitly nullable)
12. **Timestamp Format Validation**: Given a narrative entry with ISO 8601 timestamp "2024-01-01T00:00:00Z", when parsed, then it returns success
13. **History Summary Optional Field**: Given an adventure_loaded message without summary field, when parsed, then it returns success with summary undefined
14. **RPG Type Backward Compatibility**: Given a PlayerCharacter with only name and attributes (no RPG fields), when parsed, then it returns success (all RPG fields are optional)
15. **All Message Types Validated**: Given test suite execution, when all message type tests run, then 100% of defined message types have validation test coverage

## Resolved Questions

- [x] **Protocol versioning**: Not needed. This is a LAN-only system where frontend and backend are always deployed together. Version negotiation adds complexity without benefit.
- [x] **Panel position validation**: Backend specifies position type only (sidebar/header/overlay). Frontend determines actual x/y coordinates for overlay panels. No cross-boundary validation needed.
- [x] **Array length constraints**: Not enforced at protocol level. History compaction is handled by `history-compactor.ts` in the backend, keeping this module focused on schema validation only.
- [x] **Timestamp validation**: Validate ISO 8601 format, but coerce invalid timestamps to undefined rather than rejecting the message. Timestamps are informational, not critical path.
- [x] **Schema migration**: Not needed. Same rationale as protocol versioningâ€”frontend and backend are never out of sync in this deployment model.

## Out of Scope

- WebSocket connection management (handled by frontend useWebSocket hook and backend server)
- Message serialization/deserialization (JSON.stringify/parse handled by consumers)
- Authentication token generation and validation (handled by backend auth layer)
- Session state management (handled by GameSession in backend)
- Message routing and dispatch (handled by message handlers in frontend/backend)
- Rate limiting and message throttling (handled by backend server layer)
- Message encryption or compression (handled at transport layer if needed)
- Protocol versioning and migration (deferred until protocol evolution requirements emerge)
- Message queue management (handled by GameSession input queue)
- Retry logic for failed messages (handled by consumers)

---

**Next Phase**: This is a reverse-engineered specification. Use `/spiral-grove:plan-generation` if refactoring or extending the protocol module is needed.
